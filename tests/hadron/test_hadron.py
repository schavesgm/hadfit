# -- Import third-party modules
import pytest
import numpy as np

# -- Import user-defined modules
from hadfit import Hadron
from hadfit import hadron_from_fastsum
from hadfit import exp_ansatz

@pytest.fixture(scope = "session")
def generate_vector():
    yield hadron_from_fastsum('./data/64x32_ll', 'uu', 'gi')

@pytest.fixture(scope = "session")
def generate_fake_hadron():
    # -- Generate some fake configurations of 128 numbers
    data = np.stack(
        [np.exp(- 0.05 * np.arange(128)) for _ in range(500)], 0
    ).flatten()

    # -- Yield the hadron
    yield Hadron(data, 128, 'fake')

class TestHadron:

    def test_initialiser(self, generate_vector, generate_fake_hadron):
        """ Check that the initiliser is working as intended. """

        # -- Check the non-integrated dimensions are correct
        assert generate_vector.Nk      == 64
        assert generate_fake_hadron.Nk == 128

        # -- Check the number of configurations is correct
        assert generate_vector.Nc      == 3 * 8328
        assert generate_fake_hadron.Nc == 500

        # -- Check the data stored dimensions are correct
        assert generate_vector.data.shape      == (3 * 8328, 64)
        assert generate_fake_hadron.data.shape == (500, 128)

        # -- Reference to the vector information
        vecinf = generate_vector.info

        # -- A fastsum hadron must contain some relevant information
        assert 'flavour' in vecinf.keys()
        assert 'channel' in vecinf.keys()
        assert 'Ns'      in vecinf.keys()
        assert 'sources' in vecinf.keys()

        # -- Generate the vector name to be tested
        vec_name = str(vecinf['channel']) + '_' + str(vecinf['flavour']) + '_' + vecinf['sources']

        # -- Assert the names of the hadron
        assert generate_fake_hadron.name == 'fake'
        assert generate_vector.name      == vec_name
    
    def test_addition(self, generate_fake_hadron):
        """ The addition of two Hadrons is another hadron concatenated at axis = 0. """
        # -- Generate a new Hadron by adding two hadrons
        hadron = generate_fake_hadron + generate_fake_hadron
    
        # -- Assert the dimensions of the new hadron
        assert hadron.Nk == generate_fake_hadron.Nk
        assert hadron.Nc == 2 * generate_fake_hadron.Nc
    
    def test_information(self, generate_fake_hadron):
        """ Test the information manipulation in a hadron. """
        
        # -- Add some information to the hadron
        generate_fake_hadron.set_info(identifier = 'fake_hadron')
        generate_fake_hadron.set_info(numbers = [10, 20, 30])

        # -- Check the information has been added
        assert 'identifier' in generate_fake_hadron.info.keys()
        assert 'numbers'    in generate_fake_hadron.info.keys()
        assert generate_fake_hadron.info['identifier'] == 'fake_hadron'
        assert generate_fake_hadron.info['numbers']    == [10, 20, 30]

        # -- Delete the information
        generate_fake_hadron.del_info('identifier')
        generate_fake_hadron.del_info('numbers')

    def test_fold_and_normalise(self, generate_vector):
        """ Test the fold and normalise from an hadron. """

        # -- Fold and normalise the hadron
        data = generate_vector.fold_and_normalise(True, True)

        # -- Assert some properties on the data
        assert data.shape == (generate_vector.Nc, generate_vector.Nk // 2 + 1)
        assert np.mean(data, axis = 0)[-1]  == pytest.approx(1.0)

    def test_effective_mass(self, generate_fake_hadron):
        """ Test the effective mass computation on fake data. """

        # -- Compute the effective mass
        eff_mass = generate_fake_hadron.effective_mass(80, 100, exp_ansatz, False)

        # -- Assert its value is close to 0.05
        assert np.mean(eff_mass) == pytest.approx(0.05)

    def test_nk_vector(self, generate_vector):
        """ Test the generation of the vector of non-integrated variables. """

        # -- Generate a range of size Nk
        nk_check = np.arange(generate_vector.Nk)

        # -- If the data is not folded, then it is a numpy arange
        assert np.array_equal(generate_vector.nk(False), nk_check)

        # -- If the data is folded, then it is cropped
        assert np.array_equal(generate_vector.nk(True), nk_check[:generate_vector.Nk // 2 + 1])

    def test_statistics_shape(self, generate_vector):
        """ Test the shapes of the statistics generated by the Hadron class. """

        # -- Get a reference to Nk
        Nk = generate_vector.Nk

        assert generate_vector.central_value().size       == Nk
        assert generate_vector.standard_error().size      == Nk
        assert generate_vector.covariance_matrix().shape  == (Nk, Nk)
        assert generate_vector.correlation_matrix().shape == (Nk, Nk)
